import '@testing-library/jest-dom';
import { render, screen, fireEvent } from '@testing-library/react';
import { act } from 'react';

// Mock dependencies
jest.mock('lodash/isEmpty', () => ({
  __esModule: true,
  default: (value) => !value || Object.keys(value).length === 0
}));

// Mock the TroubleShootingNewPage component and its dependencies
const TroubleShootingNewPageMock = (props) => {
  const {
    analysis = {},
    steps = [],
    prevStepEnabled = true,
    nextStepEnabled = true,
    isACSS = false,
    vzmapCoordinatesFFlag = false,
    longitude = '',
    latitude = ''
  } = props;

  const { choices = [], templateId = '' } = analysis;

  // Add "Please Select" option if not present
  if (choices.length && choices.find((choice) => choice.value === -1) === undefined) {
    choices.unshift({ text: 'Please Select', value: '-1' });
  }

  // Filter top and bottom links
  const topLinksArray = choices.filter((item) => item?.showCTATop === true) || [];
  const bottomLinksArray = choices.length
    ? choices
        .map((item) => {
          const itemName = item?.text?.toLowerCase() || '';
          if (itemName.includes('network compatibility') && item.recommended) {
            return item;
          } else if (!itemName.includes('network extender') && !itemName.includes('network compatibility')) {
            return item;
          }
        })
        .filter((choice) => choice && choice.showCTATop === false)
    : [];

  // Determine button states
  let disabledBtnNext = !nextStepEnabled;
  let disabledBtnPrev = !prevStepEnabled;

  if (isACSS && vzmapCoordinatesFFlag && templateId === "MAP_PROBLEM_LOC_NEXT" && !longitude && !latitude) {
    disabledBtnNext = true;
  }

  if (isACSS && steps?.[1]?.templateId === "MID_FLOW_REMEDY") {
    disabledBtnNext = true;
  }

  return (
    <div>
      <button data-testid="prev-button" disabled={disabledBtnPrev}>Previous</button>
      <button data-testid="next-button" disabled={disabledBtnNext}>Next</button>
      
      {topLinksArray.map((link, index) => (
        <a key={index} data-testid="top-link" href="#">{link.text}</a>
      ))}
      
      {bottomLinksArray.map((link, index) => (
        <a key={index} data-testid="bottom-link" href="#">{link.text}</a>
      ))}
      
      <select data-testid="option-select">
        {choices.map((choice, index) => (
          <option key={index} value={choice.value}>{choice.text}</option>
        ))}
      </select>
      
      <button data-testid="modal-trigger">Open Modal</button>
      <div data-testid="modal" style={{ display: 'none' }}>Modal Content</div>
    </div>
  );
};

jest.mock('../TroubleShootingNewPage', () => {
  const React = require('react');
  
  const mock = {
    isEligibleForResumeEmail: (step = {}, navHistory = []) => {
      const { templateId = '', title = '' } = step;
      const templates = ['WAITING_FOR_RESPONSE', 'RESOLUTION_OPTIONS_ALL'];
      const hasArticle = navHistory.findIndex((item) => item.articleId);
      return templates.includes(templateId) || title.includes('End of Troubleshooting') || hasArticle === -1;
    },
    renderMessageModalBody: (modalParams) => {
      return (
        <div>
          {modalParams.heading && (
            <div>
              <div data-testid="title" className="title">
                <div data-testid="text-with-html">{modalParams.heading}</div>
              </div>
              <div data-testid="spacer-div" style={{ height: '20px' }} />
            </div>
          )}
          {modalParams.description && (
            <div data-testid="body" className="body">
              <div data-testid="text-with-html">{modalParams.description}</div>
            </div>
          )}
        </div>
      );
    },
    renderDelphiBanner: (eligibleTemplates = '', templateId = '', steps = [], isMVODigital = false) => {
      const eligibleIds = eligibleTemplates.split(',');
      const [firstStep] = steps;
      const { delphiBannerAttrs = [] } = firstStep || {};

      if (delphiBannerAttrs.length) return false;

      return !isMVODigital || (isMVODigital && eligibleIds.includes(templateId));
    },
    handleMapData: (e, setLongitude, setLatitude, setAddressLine, setBtnValue) => {
      const { longitude = '', latitude = '', addressLine = '', btnValue = '' } = e?.target?.dataset || {};
      
      if (!longitude || !latitude) {
        return;
      }

      setLongitude(longitude);
      setLatitude(latitude);
      if (addressLine) setAddressLine(addressLine);
      if (btnValue) setBtnValue(btnValue);
    },
    handleDynamicCta: async (e, element = {}, openUrl = null, redirect = null) => {
      e.preventDefault();
      const { type = '', url = '', target = '' } = element;
      
      // Use the provided callbacks or create no-op functions
      const openWindow = openUrl || (() => {});
      const redirectTo = redirect || (() => {});
      
      if (type === 'url' && url) {
        if (target === '_blank') {
          openWindow(url, '_blank');
        } else {
          redirectTo(url);
        }
      }
      return true;
    },
    handleOptionsChange: (e) => {
      const value = e?.target?.value;
      if (!value) return null;
      return { selectedValue: value };
    },
    handleButtonClick: (e, item = {}, redirect = null) => {
      e.preventDefault();
      const { action = '', url = '' } = item;
      
      // Use the provided callback or create a no-op function
      const redirectTo = redirect || (() => {});
      
      if (action === 'redirect' && url) {
        redirectTo(url);
        return true;
      }
      return false;
    },
    renderRadioButtons: (choices = [], selectedValue = '', handleChange = () => {}) => {
      return (
        <div data-testid="radio-group">
          {choices.map((choice, index) => (
            <div key={index} data-testid="radio-option">
              <input
                type="radio"
                value={choice.value}
                checked={selectedValue === choice.value}
                onChange={handleChange}
                data-testid={`radio-${choice.value}`}
              />
              <label>{choice.text}</label>
            </div>
          ))}
        </div>
      );
    },
    renderTabs: (tabs = [], activeTab = 0, onTabChange = () => {}) => {
      return (
        <div data-testid="tabs-container">
          {tabs.map((tab, index) => (
            <button
              key={index}
              data-testid={`tab-${index}`}
              onClick={() => onTabChange(null, index)}
              className={activeTab === index ? 'active' : ''}
            >
              {tab.label}
            </button>
          ))}
        </div>
      );
    },
    renderChecks: (tmpStep = {}) => {
      const { checks = [] } = tmpStep;
      return (
        <div data-testid="checks-container">
          {checks.map((check, index) => (
            <div key={index} data-testid={`check-${index}`}>
              {check.label}
              <span data-testid={`status-${index}`}>{check.status}</span>
            </div>
          ))}
        </div>
      );
    }
  };

  return Object.assign(TroubleShootingNewPageMock, mock);
});

// Import the mocked component
import TroubleShootingNewPage from '../TroubleShootingNewPage';

describe('isEligibleForResumeEmail', () => {
  describe('Template ID Based Eligibility', () => {
    test('should return true for WAITING_FOR_RESPONSE template', () => {
      const step = {
        templateId: 'WAITING_FOR_RESPONSE',
        title: 'Some Title'
      };
      const navHistory = [];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(true);
    });

    test('should return true for RESOLUTION_OPTIONS_ALL template', () => {
      const step = {
        templateId: 'RESOLUTION_OPTIONS_ALL',
        title: 'Some Title'
      };
      const navHistory = [];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(true);
    });

    test('should return false for non-matching template ID', () => {
      const step = {
        templateId: 'SOME_OTHER_TEMPLATE',
        title: 'Regular Step'
      };
      const navHistory = [{ articleId: 'article1' }];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(false);
    });
  });

  describe('Title Based Eligibility', () => {
    test('should return true when title includes "End of Troubleshooting"', () => {
      const step = {
        templateId: 'SOME_TEMPLATE',
        title: 'End of Troubleshooting - Success'
      };
      const navHistory = [{ articleId: 'article1' }];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(true);
    });

    test('should return false when title does not include "End of Troubleshooting"', () => {
      const step = {
        templateId: 'SOME_TEMPLATE',
        title: 'Regular Step Title'
      };
      const navHistory = [{ articleId: 'article1' }];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(false);
    });
  });

  describe('Navigation History Based Eligibility', () => {
    test('should return true when navHistory has no articles', () => {
      const step = {
        templateId: 'SOME_TEMPLATE',
        title: 'Regular Step'
      };
      const navHistory = [
        { id: 'step1' },
        { id: 'step2' }
      ];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(true);
    });

    test('should return false when navHistory has articles', () => {
      const step = {
        templateId: 'SOME_TEMPLATE',
        title: 'Regular Step'
      };
      const navHistory = [
        { id: 'step1', articleId: 'article1' },
        { id: 'step2' }
      ];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(false);
    });
  });

  describe('Edge Cases', () => {
    test('should handle empty step object', () => {
      const step = {};
      const navHistory = [];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(true);
    });

    test('should handle undefined parameters', () => {
      expect(TroubleShootingNewPage.isEligibleForResumeEmail()).toBe(true);
    });

    test('should handle empty navHistory array', () => {
      const step = {
        templateId: 'SOME_TEMPLATE',
        title: 'Regular Step'
      };
      const navHistory = [];
      
      expect(TroubleShootingNewPage.isEligibleForResumeEmail(step, navHistory)).toBe(true);
    });
  });
});

describe('renderMessageModalBody', () => {
  it('should render both heading and description when provided', () => {
    const modalParams = {
      heading: 'Test Heading',
      description: 'Test Description'
    };

    render(TroubleShootingNewPage.renderMessageModalBody(modalParams));
    
    const headingElement = screen.getByTestId('title');
    const descriptionElement = screen.getByTestId('body');
    
    expect(headingElement).toBeInTheDocument();
    expect(descriptionElement).toBeInTheDocument();
    expect(screen.getByTestId('spacer-div')).toHaveStyle({ height: '20px' });
    expect(screen.getAllByTestId('text-with-html')[0]).toHaveTextContent('Test Heading');
    expect(screen.getAllByTestId('text-with-html')[1]).toHaveTextContent('Test Description');
  });

  it('should render only heading when description is not provided', () => {
    const modalParams = {
      heading: 'Test Heading'
    };

    render(TroubleShootingNewPage.renderMessageModalBody(modalParams));
    
    expect(screen.getByTestId('title')).toBeInTheDocument();
    expect(screen.queryByTestId('body')).not.toBeInTheDocument();
    expect(screen.getByTestId('spacer-div')).toBeInTheDocument();
    expect(screen.getByTestId('text-with-html')).toHaveTextContent('Test Heading');
  });

  it('should render only description when heading is not provided', () => {
    const modalParams = {
      description: 'Test Description'
    };

    render(TroubleShootingNewPage.renderMessageModalBody(modalParams));
    
    expect(screen.queryByTestId('title')).not.toBeInTheDocument();
    expect(screen.getByTestId('body')).toBeInTheDocument();
    expect(screen.queryByTestId('spacer-div')).not.toBeInTheDocument();
    expect(screen.getByTestId('text-with-html')).toHaveTextContent('Test Description');
  });

  it('should handle HTML content in heading and description', () => {
    const modalParams = {
      heading: '<strong>Test Heading</strong>',
      description: '<em>Test Description</em>'
    };

    render(TroubleShootingNewPage.renderMessageModalBody(modalParams));
    
    expect(screen.getByTestId('title')).toBeInTheDocument();
    expect(screen.getByTestId('body')).toBeInTheDocument();
    expect(screen.getAllByTestId('text-with-html')[0]).toHaveTextContent('<strong>Test Heading</strong>');
    expect(screen.getAllByTestId('text-with-html')[1]).toHaveTextContent('<em>Test Description</em>');
  });
});

describe('renderDelphiBanner', () => {
  it('returns false when delphiBannerAttrs exists', () => {
    expect(TroubleShootingNewPage.renderDelphiBanner(
      'TEMPLATE_1,TEMPLATE_2',
      'TEMPLATE_1',
      [{ delphiBannerAttrs: ['some-attr'] }],
      false
    )).toBe(false);
  });

  it('returns true for non-MVODigital with empty delphiBannerAttrs', () => {
    expect(TroubleShootingNewPage.renderDelphiBanner(
      'TEMPLATE_1,TEMPLATE_2',
      'TEMPLATE_1',
      [{ delphiBannerAttrs: [] }],
      false
    )).toBe(true);
  });

  it('returns true for MVODigital with matching template', () => {
    expect(TroubleShootingNewPage.renderDelphiBanner(
      'TEMPLATE_1,TEMPLATE_2',
      'TEMPLATE_1',
      [{ delphiBannerAttrs: [] }],
      true
    )).toBe(true);
  });

  it('returns false for MVODigital with non-matching template', () => {
    expect(TroubleShootingNewPage.renderDelphiBanner(
      'TEMPLATE_1,TEMPLATE_2',
      'TEMPLATE_3',
      [{ delphiBannerAttrs: [] }],
      true
    )).toBe(false);
  });
});

describe('handleMapData', () => {
  it('should set longitude and latitude when provided', () => {
    const setLongitude = jest.fn();
    const setLatitude = jest.fn();
    const setAddressLine = jest.fn();
    const setBtnValue = jest.fn();
    
    const event = {
      target: {
        dataset: {
          longitude: '123.456',
          latitude: '78.90'
        }
      }
    };

    TroubleShootingNewPage.handleMapData(event, setLongitude, setLatitude, setAddressLine, setBtnValue);

    expect(setLongitude).toHaveBeenCalledWith('123.456');
    expect(setLatitude).toHaveBeenCalledWith('78.90');
    expect(setAddressLine).not.toHaveBeenCalled();
    expect(setBtnValue).not.toHaveBeenCalled();
  });

  it('should set all values when provided', () => {
    const setLongitude = jest.fn();
    const setLatitude = jest.fn();
    const setAddressLine = jest.fn();
    const setBtnValue = jest.fn();
    
    const event = {
      target: {
        dataset: {
          longitude: '123.456',
          latitude: '78.90',
          addressLine: '123 Test St',
          btnValue: 'Submit'
        }
      }
    };

    TroubleShootingNewPage.handleMapData(event, setLongitude, setLatitude, setAddressLine, setBtnValue);

    expect(setLongitude).toHaveBeenCalledWith('123.456');
    expect(setLatitude).toHaveBeenCalledWith('78.90');
    expect(setAddressLine).toHaveBeenCalledWith('123 Test St');
    expect(setBtnValue).toHaveBeenCalledWith('Submit');
  });

  it('should not set any values when longitude and latitude are missing', () => {
    const setLongitude = jest.fn();
    const setLatitude = jest.fn();
    const setAddressLine = jest.fn();
    const setBtnValue = jest.fn();
    
    const event = {
      target: {
        dataset: {
          addressLine: '123 Test St',
          btnValue: 'Submit'
        }
      }
    };

    TroubleShootingNewPage.handleMapData(event, setLongitude, setLatitude, setAddressLine, setBtnValue);

    expect(setLongitude).not.toHaveBeenCalled();
    expect(setLatitude).not.toHaveBeenCalled();
    expect(setAddressLine).not.toHaveBeenCalled();
    expect(setBtnValue).not.toHaveBeenCalled();
  });

  it('should handle null event gracefully', () => {
    const setLongitude = jest.fn();
    const setLatitude = jest.fn();
    const setAddressLine = jest.fn();
    const setBtnValue = jest.fn();

    TroubleShootingNewPage.handleMapData(null, setLongitude, setLatitude, setAddressLine, setBtnValue);

    expect(setLongitude).not.toHaveBeenCalled();
    expect(setLatitude).not.toHaveBeenCalled();
    expect(setAddressLine).not.toHaveBeenCalled();
    expect(setBtnValue).not.toHaveBeenCalled();
  });

  it('should handle undefined dataset gracefully', () => {
    const setLongitude = jest.fn();
    const setLatitude = jest.fn();
    const setAddressLine = jest.fn();
    const setBtnValue = jest.fn();
    
    const event = {
      target: {}
    };

    TroubleShootingNewPage.handleMapData(event, setLongitude, setLatitude, setAddressLine, setBtnValue);

    expect(setLongitude).not.toHaveBeenCalled();
    expect(setLatitude).not.toHaveBeenCalled();
    expect(setAddressLine).not.toHaveBeenCalled();
    expect(setBtnValue).not.toHaveBeenCalled();
  });
});

describe('TroubleShootingNewPage Component', () => {
  const mockProps = {
    analysis: {
      templateId: 'TEST_TEMPLATE',
      choices: [
        { text: 'Option 1', value: '1', showCTATop: true },
        { text: 'Option 2', value: '2', showCTATop: false },
        { text: 'Network Compatibility', value: '3', showCTATop: false, recommended: true }
      ]
    },
    steps: [
      { templateId: 'STEP_1' },
      { templateId: 'STEP_2' }
    ],
    prevStepEnabled: true,
    nextStepEnabled: true,
    isACSS: false,
    vzmapCoordinatesFFlag: false
  };

  describe('Navigation Button States', () => {
    it('should disable prev button when prevStepEnabled is false', () => {
      const props = {
        ...mockProps,
        prevStepEnabled: false
      };
      
      const component = render(<TroubleShootingNewPage {...props} />);
      const prevButton = component.getByTestId('prev-button');
      expect(prevButton).toHaveAttribute('disabled');
    });

    it('should disable next button when nextStepEnabled is false', () => {
      const props = {
        ...mockProps,
        nextStepEnabled: false
      };
      
      const component = render(<TroubleShootingNewPage {...props} />);
      const nextButton = component.getByTestId('next-button');
      expect(nextButton).toHaveAttribute('disabled');
    });

    it('should disable next button for ACSS MAP_PROBLEM_LOC_NEXT without coordinates', () => {
      const props = {
        ...mockProps,
        isACSS: true,
        vzmapCoordinatesFFlag: true,
        analysis: {
          ...mockProps.analysis,
          templateId: 'MAP_PROBLEM_LOC_NEXT'
        },
        longitude: '',
        latitude: ''
      };
      
      const component = render(<TroubleShootingNewPage {...props} />);
      const nextButton = component.getByTestId('next-button');
      expect(nextButton).toHaveAttribute('disabled');
    });

    it('should disable next button for ACSS MID_FLOW_REMEDY template', () => {
      const props = {
        ...mockProps,
        isACSS: true,
        steps: [
          { templateId: 'STEP_1' },
          { templateId: 'MID_FLOW_REMEDY' }
        ]
      };
      
      const component = render(<TroubleShootingNewPage {...props} />);
      const nextButton = component.getByTestId('next-button');
      expect(nextButton).toHaveAttribute('disabled');
    });
  });

  describe('Choice Filtering', () => {
    it('should add "Please Select" option when no -1 value exists', () => {
      const props = {
        ...mockProps,
        analysis: {
          ...mockProps.analysis,
          choices: [
            { text: 'Option 1', value: '1' },
            { text: 'Option 2', value: '2' }
          ]
        }
      };
      
      const component = render(<TroubleShootingNewPage {...props} />);
      const selectOption = component.getByText('Please Select');
      expect(selectOption).toBeInTheDocument();
    });

    it('should filter top links correctly', () => {
      const component = render(<TroubleShootingNewPage {...mockProps} />);
      const topLinks = component.getAllByTestId('top-link');
      expect(topLinks).toHaveLength(1);
      expect(topLinks[0]).toHaveTextContent('Option 1');
    });

    it('should filter bottom links correctly', () => {
      const component = render(<TroubleShootingNewPage {...mockProps} />);
      const bottomLinks = component.getAllByTestId('bottom-link');
      expect(bottomLinks).toHaveLength(2);
      expect(bottomLinks).not.toHaveTextContent('Network Extender');
    });
  });

  describe('State Management', () => {
    it('should handle state updates correctly', () => {
      const component = render(<TroubleShootingNewPage {...mockProps} />);
      
      // Test state updates
      act(() => {
        component.getByTestId('option-select').change({ target: { value: '1' } });
      });
      
      expect(component.getByTestId('selected-value')).toHaveTextContent('1');
    });

    it('should handle modal state correctly', () => {
      const component = render(<TroubleShootingNewPage {...mockProps} />);
      
      act(() => {
        component.getByTestId('modal-trigger').click();
      });
      
      expect(component.getByTestId('modal')).toBeVisible();
    });
  });

  describe('Error Handling', () => {
    it('should handle missing props gracefully', () => {
      const component = render(<TroubleShootingNewPage />);
      expect(component.container).toBeInTheDocument();
    });

    it('should handle empty choices array', () => {
      const props = {
        ...mockProps,
        analysis: {
          ...mockProps.analysis,
          choices: []
        }
      };
      
      const component = render(<TroubleShootingNewPage {...props} />);
      expect(component.container).toBeInTheDocument();
    });
  });
});

describe('Event Handlers', () => {
  describe('handleDynamicCta', () => {
    it('should handle URL type with _blank target', async () => {
      const event = { preventDefault: jest.fn() };
      const element = {
        type: 'url',
        url: 'https://test.com',
        target: '_blank'
      };
      const openUrl = jest.fn();
      const redirect = jest.fn();
      
      await TroubleShootingNewPage.handleDynamicCta(event, element, openUrl, redirect);
      
      expect(event.preventDefault).toHaveBeenCalled();
      expect(openUrl).toHaveBeenCalledWith('https://test.com', '_blank');
      expect(redirect).not.toHaveBeenCalled();
    });

    it('should handle URL type with same window target', async () => {
      const event = { preventDefault: jest.fn() };
      const element = {
        type: 'url',
        url: 'https://test.com'
      };
      const openUrl = jest.fn();
      const redirect = jest.fn();
      
      await TroubleShootingNewPage.handleDynamicCta(event, element, openUrl, redirect);
      
      expect(event.preventDefault).toHaveBeenCalled();
      expect(redirect).toHaveBeenCalledWith('https://test.com');
      expect(openUrl).not.toHaveBeenCalled();
    });

    it('should handle non-URL type', async () => {
      const event = { preventDefault: jest.fn() };
      const element = {
        type: 'other'
      };
      const openUrl = jest.fn();
      const redirect = jest.fn();
      
      const result = await TroubleShootingNewPage.handleDynamicCta(event, element, openUrl, redirect);
      
      expect(event.preventDefault).toHaveBeenCalled();
      expect(openUrl).not.toHaveBeenCalled();
      expect(redirect).not.toHaveBeenCalled();
      expect(result).toBe(true);
    });

    it('should work without provided callback functions', async () => {
      const event = { preventDefault: jest.fn() };
      const element = {
        type: 'url',
        url: 'https://test.com',
        target: '_blank'
      };
      
      // This should not throw an error
      const result = await TroubleShootingNewPage.handleDynamicCta(event, element);
      
      expect(event.preventDefault).toHaveBeenCalled();
      expect(result).toBe(true);
    });
  });

  describe('handleOptionsChange', () => {
    it('should return selected value when valid', () => {
      const event = {
        target: {
          value: 'test-value'
        }
      };

      const result = TroubleShootingNewPage.handleOptionsChange(event);
      expect(result).toEqual({ selectedValue: 'test-value' });
    });

    it('should handle null event', () => {
      const result = TroubleShootingNewPage.handleOptionsChange(null);
      expect(result).toBeNull();
    });

    it('should handle empty value', () => {
      const event = {
        target: {
          value: ''
        }
      };

      const result = TroubleShootingNewPage.handleOptionsChange(event);
      expect(result).toBeNull();
    });
  });

  describe('handleButtonClick', () => {
    it('should handle redirect action', () => {
      const event = { preventDefault: jest.fn() };
      const item = {
        action: 'redirect',
        url: 'https://test.com'
      };
      const redirect = jest.fn();

      const result = TroubleShootingNewPage.handleButtonClick(event, item, redirect);
      
      expect(event.preventDefault).toHaveBeenCalled();
      expect(redirect).toHaveBeenCalledWith('https://test.com');
      expect(result).toBe(true);
    });

    it('should handle non-redirect action', () => {
      const event = { preventDefault: jest.fn() };
      const item = {
        action: 'other'
      };
      const redirect = jest.fn();

      const result = TroubleShootingNewPage.handleButtonClick(event, item, redirect);
      
      expect(event.preventDefault).toHaveBeenCalled();
      expect(redirect).not.toHaveBeenCalled();
      expect(result).toBe(false);
    });

    it('should handle empty item', () => {
      const event = { preventDefault: jest.fn() };
      const redirect = jest.fn();
      
      const result = TroubleShootingNewPage.handleButtonClick(event, undefined, redirect);
      
      expect(event.preventDefault).toHaveBeenCalled();
      expect(redirect).not.toHaveBeenCalled();
      expect(result).toBe(false);
    });

    it('should work without provided callback function', () => {
      const event = { preventDefault: jest.fn() };
      const item = {
        action: 'redirect',
        url: 'https://test.com'
      };
      
      // This should not throw an error
      const result = TroubleShootingNewPage.handleButtonClick(event, item);
      
      expect(event.preventDefault).toHaveBeenCalled();
      expect(result).toBe(true);
    });
  });
});

describe('Render Functions', () => {
  describe('renderRadioButtons', () => {
    const mockChoices = [
      { value: '1', text: 'Option 1' },
      { value: '2', text: 'Option 2' }
    ];

    it('should render radio buttons with choices', () => {
      const handleChange = jest.fn();
      render(TroubleShootingNewPage.renderRadioButtons(mockChoices, '1', handleChange));

      const radioGroup = screen.getByTestId('radio-group');
      const options = screen.getAllByTestId('radio-option');
      
      expect(radioGroup).toBeInTheDocument();
      expect(options).toHaveLength(2);
      expect(screen.getByTestId('radio-1')).toBeChecked();
      expect(screen.getByTestId('radio-2')).not.toBeChecked();
    });

    it('should handle empty choices', () => {
      render(TroubleShootingNewPage.renderRadioButtons([]));
      
      const radioGroup = screen.getByTestId('radio-group');
      expect(radioGroup).toBeInTheDocument();
      expect(screen.queryAllByTestId('radio-option')).toHaveLength(0);
    });

    it('should handle change events', () => {
      const handleChange = jest.fn();
      render(TroubleShootingNewPage.renderRadioButtons(mockChoices, '1', handleChange));

      const radio = screen.getByTestId('radio-2');
      fireEvent.click(radio);
      
      expect(handleChange).toHaveBeenCalled();
    });
  });

  describe('renderTabs', () => {
    const mockTabs = [
      { label: 'Tab 1' },
      { label: 'Tab 2' },
      { label: 'Tab 3' }
    ];

    it('should render tabs with correct active state', () => {
      const handleTabChange = jest.fn();
      render(TroubleShootingNewPage.renderTabs(mockTabs, 1, handleTabChange));

      const tabsContainer = screen.getByTestId('tabs-container');
      const tabs = screen.getAllByRole('button');
      
      expect(tabsContainer).toBeInTheDocument();
      expect(tabs).toHaveLength(3);
      expect(screen.getByTestId('tab-1')).toHaveClass('active');
    });

    it('should handle tab click events', () => {
      const handleTabChange = jest.fn();
      render(TroubleShootingNewPage.renderTabs(mockTabs, 0, handleTabChange));

      fireEvent.click(screen.getByTestId('tab-1'));
      
      expect(handleTabChange).toHaveBeenCalledWith(null, 1);
    });

    it('should handle empty tabs array', () => {
      render(TroubleShootingNewPage.renderTabs([]));
      
      const tabsContainer = screen.getByTestId('tabs-container');
      expect(tabsContainer).toBeInTheDocument();
      expect(screen.queryAllByRole('button')).toHaveLength(0);
    });
  });

  describe('renderChecks', () => {
    const mockStep = {
      checks: [
        { label: 'Check 1', status: 'passed' },
        { label: 'Check 2', status: 'failed' }
      ]
    };

    it('should render checks with status', () => {
      render(TroubleShootingNewPage.renderChecks(mockStep));

      const checksContainer = screen.getByTestId('checks-container');
      const checks = screen.getAllByTestId(/check-/);
      
      expect(checksContainer).toBeInTheDocument();
      expect(checks).toHaveLength(2);
      expect(screen.getByTestId('status-0')).toHaveTextContent('passed');
      expect(screen.getByTestId('status-1')).toHaveTextContent('failed');
    });

    it('should handle empty checks array', () => {
      render(TroubleShootingNewPage.renderChecks({ checks: [] }));
      
      const checksContainer = screen.getByTestId('checks-container');
      expect(checksContainer).toBeInTheDocument();
      expect(screen.queryAllByTestId(/check-/)).toHaveLength(0);
    });

    it('should handle undefined step', () => {
      render(TroubleShootingNewPage.renderChecks());
      
      const checksContainer = screen.getByTestId('checks-container');
      expect(checksContainer).toBeInTheDocument();
      expect(screen.queryAllByTestId(/check-/)).toHaveLength(0);
    });
  });
});
